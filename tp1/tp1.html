<!doctype html>
<head>
    <script src="js/jquery.js"></script>
    <script src="js/gl-matrix-3.3.0.js"></script>    
    <script src="js/webgl-utils.js"></script>
    <script src="js/dat.gui.js"></script>
    <script src="vector.js"></script>
    <script src="discretizador.js"></script>
    <script src="modulo-geometria.js"></script>
    <script src="controlHelicoptero.js"></script>
    <script src="modulo-obj3d.js"></script>

<style>
        html{
            height: 100%;
        }
        body{
            padding: 0;
            margin: 0;
            height: 100%;;
        }

        #myCanvas{
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
    </style>

</head>

<body>
           
    <canvas id="myCanvas" >
        Your browser does not support the HTML5 canvas element.
    </canvas>
        
    
    <script>

        var vertexShaderFile="vertex-shader.glsl";
        var modo="smooth"; // wireframe, smooth, edges
        var shaderProgram;
        var time=0;

        var gl;
        var mat4=glMatrix.mat4;
        var mat3=glMatrix.mat3;
        var vec3=glMatrix.vec3;   
        
        var earth;
            
        var $canvas=$("#myCanvas");
        var aspect=$canvas.width()/$canvas.height();

        var distanciaCamara=3;
        var alturaCamara=2;
        var velocidadAngular=0.15;
        
        var lighting="true";

        var vertexShaderSource;
        var fragmentShaderSource;

        var matrizProyeccion = mat4.create();            
        var matrizVista = mat4.create();            
        var matrizModelado = mat4.create();

        var controlHelicoptero=new ControlHelicoptero();        
        
        var objetosEscena = [];

        function initGL(canvas) {

            try {
                gl = canvas.getContext("webgl");
                gl.canvas.width=$canvas.width();
                gl.canvas.height=$canvas.height();                
            } catch (e) {
                console.error(e);
            }
            if (!gl) {
                alert("Could not initialise WebGL, sorry :-(");
            }
        }

        function loadShaders(){

            $.when(loadVS(), loadFS()).done(function(res1,res2){
                //this code is executed when all ajax calls are done     
                webGLStart();
            });

            function loadVS() {
                return  $.ajax({
                    url: "shaders/"+vertexShaderFile,
                    success: function(result){
                        vertexShaderSource=result;
                    }
                });
            }   

            function loadFS() {
                return  $.ajax({
                    url: "shaders/fragment-shader.glsl",
                    success: function(result){
                        fragmentShaderSource=result;
                    }
                });
            }
        }
        
        function getShader(gl,code,type) {

            var shader;

            if (type == "fragment") 
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            else // "vertex"
                shader = gl.createShader(gl.VERTEX_SHADER);
            
            gl.shaderSource(shader, code);
            gl.compileShader(shader);
    
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }    
            return shader;
        }
        
        function onResize(){
            gl.canvas.width=$canvas.width();
            gl.canvas.height=$canvas.height();
            aspect=$canvas.width()/$canvas.height();
        }

        function getShaderSource(url) {
            var req = new XMLHttpRequest();
            req.open("GET", url, false);
            req.send(null);
            return (req.status == 200) ? req.responseText : null;
        }; 

        function initShaders() {
    
            var fragmentShader= getShader(gl, vertexShaderSource,"vertex");
            var vertexShader= getShader(gl, fragmentShaderSource,"fragment");

            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
    
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }
    
            gl.useProgram(shaderProgram);
    
            shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aPosition");
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
    
            shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aUv");
            gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
    
            shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aNormal");
            gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
    
            shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
            shaderProgram.mMatrixUniform = gl.getUniformLocation(shaderProgram, "uMMatrix");
            shaderProgram.vMatrixUniform = gl.getUniformLocation(shaderProgram, "uVMatrix");
            shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
            shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
            shaderProgram.useLightingUniform = gl.getUniformLocation(shaderProgram, "uUseLighting");
            shaderProgram.ambientColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientColor");
            shaderProgram.frameUniform = gl.getUniformLocation(shaderProgram, "time");
            shaderProgram.lightingDirectionUniform = gl.getUniformLocation(shaderProgram, "uLightPosition");
            shaderProgram.directionalColorUniform = gl.getUniformLocation(shaderProgram, "uDirectionalColor");

            Objeto3D.MODEL_MATRIX_SHADER_UNIFORM = shaderProgram.mMatrixUniform;
        }
        
    
        function setMatrixUniforms() {
            
            // gl.uniformMatrix4fv(shaderProgram.mMatrixUniform, false, matrizModelado);
            gl.uniformMatrix4fv(shaderProgram.vMatrixUniform, false, matrizVista);
            gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, matrizProyeccion);
    
            var normalMatrix = mat3.create();
            mat3.fromMat4(normalMatrix,matrizModelado); // normalMatrix= (inversa(traspuesta(matrizModelado)));
    
            mat3.invert(normalMatrix, normalMatrix);
            mat3.transpose(normalMatrix,normalMatrix);

            gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
        }
              
        function drawScene() {
        
            // Se configura el viewport dentro del "canvas". 
            // En este caso se utiliza toda el área disponible
            gl.viewport(0, 0, $canvas.width(), $canvas.height());
            
            // Se habilita el color de borrado para la pantalla (Color Buffer) y otros buffers
            gl.clearColor(0.2,0.2,0.2,1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    
            // Se configura la matriz de proyección
            mat4.identity(matrizProyeccion);
            mat4.perspective(matrizProyeccion, 65, aspect, 0.1, 100000.0);
            // mat4.scale(matrizProyeccion,matrizProyeccion,[1,-1,1]); // parche para hacer un flip de Y, parece haber un bug en glmatrix
               
            // Se inicializan las variables asociadas con la Iluminación
            
            gl.uniform1f(shaderProgram.frameUniform, time/10.0 );
            gl.uniform3f(shaderProgram.ambientColorUniform, 0.6, 0.6, 0.6 );
            gl.uniform3f(shaderProgram.directionalColorUniform, 1.2, 1.1, 0.7);
            gl.uniform1i(shaderProgram.useLightingUniform,(lighting=="true"));
                
            // // Definimos la ubicación de la camara                        
            
            // mat4.lookAt(matrizVista,
            //     vec3.fromValues(0, alturaCamara, distanciaCamara),
            //     vec3.fromValues(0,0,0),
            //     vec3.fromValues(0,1,0)
            // );

            var lightPosition = [10.0,0.0, 3.0];  
            gl.uniform3fv(shaderProgram.lightingDirectionUniform, lightPosition);            

            setMatrixUniforms();

            for (const objeto of objetosEscena) {
                objeto.dibujar(matrizModelado);
            }
            
        }
        
        function tick() {
            requestAnimFrame(tick);
            time+=1/60;
            
            controlHelicoptero.update();
            var p = controlHelicoptero.getPosition();
            var [rotX,rotY,rotZ] = controlHelicoptero.getRotaciones();

            objetosEscena[0].setPosicion(p.x, p.y, p.z);
            objetosEscena[0].setRotacion(rotX,rotY,rotZ);

            // Definimos la ubicación de la camara                        
            
            mat4.lookAt(matrizVista,
                vec3.fromValues(p.x+6, p.y+6, p.z+6),
                vec3.fromValues(p.x, p.y, p.z),
                vec3.fromValues(0,1,0)
            );

            drawScene();
        }
            
        function initMenu(){
            var gui = new dat.GUI();
            gui.add(window, "distanciaCamara",0.01,5).step(0.01);
            gui.add(window, "alturaCamara",-4,4).step(0.01);;
            gui.add(window, "modo",["wireframe","smooth","edges"]);
            gui.add(window, "velocidadAngular",0, 1).step(0.01);
            
            
        }

        function getRandomIntInclusive(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive 
        }

        function webGLStart() {
            var canvas = document.getElementById("myCanvas");
            initGL(canvas);
            initShaders();

            
            // var controlF = [[-0.5,0,0], [-0.5,1,0], [0.5,1,0], [0.5,0,0]];
            var controlF = [[0,-0.5,0], [-1,1,0], [1,1,0], [0,-0.5,0]];
            
            // var controlR = [[0,0,0], [0,0,3], [3,0,3], [3,0,0]];
            // var controlR = [[3,0,0], [3,0,3], [0,0,3], [0,0,0]];
            var controlR = [[0,0,0], [1,0,0], [2,0,0], [3,0,0]];
            
            var heli = new Objeto3D(crearGeometria(controlF, controlR));
            objetosEscena.push(heli);


            // var controlF = [[-0.5,0,0], [-0.5,1,0], [0.5,1,0], [0.5,0,0]];
            controlF = [[0,-0.5,0], [-1,1,0], [1,1,0], [0,-0.5,0]];
            
            // var controlR = [[0,0,0], [0,0,3], [3,0,3], [3,0,0]];
            controlR = [[3,0,0], [3,0,3], [0,0,3], [0,0,0]];
            
            for (let i = 0; i < 30; i++) {
                var curvita = new Objeto3D(crearGeometria(controlF, controlR));
                posx = getRandomIntInclusive(-10, 10);
                posz = getRandomIntInclusive(-10, 10);
                curvita.setPosicion(posx, 0, posz);
                objetosEscena.push(curvita);
            }

            // // var controlF = [[-0.5,0,0], [-0.5,1,0], [0.5,1,0], [0.5,0,0]];
            // controlF = [[0,-0.5,0], [-1,1,0], [1,1,0], [0,-0.5,0]];
            
            // // var controlR = [[0,0,0], [0,0,3], [3,0,3], [3,0,0]];
            // // var controlR = [[3,0,0], [3,0,3], [0,0,3], [0,0,0]];
            // controlR = [[0,0,0], [0,.5,0], [0,.5,0], [0,1,0]];
            
            // curvita = new Objeto3D(crearGeometria(controlF, controlR));
            // objetosEscena[0].agregarHijo(curvita);

            // var controlF2 = [[0,-0.5,0], [-1,1,0], [1,1,0], [0,-0.5,0]];

            // var controlR2 = [[0,0,0], [0,0,1], [0,0,2], [0,0,3]];

            // crearGeometria(controlF2, controlR2);

            gl.clearColor(66.2, 0.2, 0.2, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
    
            $(window).on("resize",onResize);
            initMenu();
            tick();
        }
    
        // cuando el documento HTML esta completo, iniciamos la aplicación
        $(document).ready(function(){
            loadShaders();
        })

    </script>
    
</body>
</html>
